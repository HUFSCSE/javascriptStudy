1. Call by value & Call by reference

[X] call by value 는 말그대로 값의 의한 전달
그렇기 때문에 함수로 값을 전달하면 그 값이 함수의 매개변수에 복사가 되며
함수 내에서 값을 아무리 바꿔도 원본의 값은 바뀌지 않습니다.

[X] call by reference
함수가 호출이 되는 시기에 매개변수 인 레퍼런스 변수가 받아오는 변수의 별명으로서 초기화가 이루어 집니다.
즉 이 레퍼런스 변수는 메모리 공간을 할당 받는것이 아닌 원본 변수의 별명으로써 존재하는 것입니다.
퍼런스 변수 는 그 변수 자체를 참조하여 값을 변경이 가능하기때문에
함수내에서 값을 변경을 해도 원본 변수의 값 역시 바뀌는 성질을 가지고 있습니다.

메서드를 호출할때 호출 하는 메서드가 인자를 필요로 하는경우 () 안에 인자를 넣어 호출한다.
이때 메서드에서 파라미터를 받아 사용할때 호출하는 방법이 2가지가 있는데 그것이 call by value, call by reference 이다.
우리말로하면 값호출, 참조호출 정도가 될것이다.
호출방법을 프로그래머가 지정할 수는 없다.
동일한 인자를 여기선 값으로, 저기선 참조로 호출할수는 없다는 얘기다.
기본적으로 자바는 8가지의 기본형 데이터에 대해선 call by value로 호출하며
그 외에 사용자지정타입. 즉 객체에 대해서만 call by reference로 호출하게된다.


2.  Method

메소드(method)

메소드는 객체가 가지고 있는 동작이다.
이 동작이란 의미에서 함수와 메소드를 구분하지 못하는 분들도 많다.
기본적으로 함수와 메소드가 서로 일련의 동작을 실행한다는 점에서 동일하기 때문이다.
하지만 메소드와 함수는 엄연하게 서로 다른 녀석이다. 메소드와 함수의 차이가 무엇인지 궁금한 분을 위해 잠깐 그 차이를 설명하고 넘어가겠다

메소드는 위에서 설명하였듯이 객체가 가지고 있는 동작이다. 메소드를 수행하기 위해서는 객체를 통해서 해당 메소드를 수행하여야 한다.
즉 그 동작을 수행하는 주체는 객체이며 그 동작을 수행하기 위해서는 객체에게 그 동작을 수행하라고 지시해야 한다.
함수는 그 동작을 수행하기 위해 객체에게 어떤을 동작을 수행하라고 명령하지 않아도 된다.
그 이유는 함수자체가 그 동작을 정의한 함수객체이기 때문에 자기 자신을 수행하는 것이다.
함수객체라는 것에 대해서는 이후에 자세히 설명하도록 하겠다.
어찌 되었건 메소드는 객체를 움직이는 동작이며 그 동작을 수행하기 위해서 객체의 정보를 담고있는 프로퍼티를 사용할수 있다.

출처: http://insanehong.kr/post/javascript-object/


3.배열에서 사용할 수 있는 메서드

Javascript Array클래스에 정의되어있는 배열 메서드
join()
Array.join()메서드는 배열의 모든 원소를 문자열로 변환하고 이어 붙여서 반환한다.

var a = [1, 2, 3];     //3개의 원소를 가진 배열을 생성
var s = a.join();      //s == "1,2,3"
s = a.join(", ");       //s == "1, 2, 3"

Array.join() 메서드는 String.split() 메서드와 반대되는 기능을 한다.

reverse()
Array.reverse() 메서드는 이름에서도 알 수 있듯이 배열 안의 원소 순서를 반대로 정렬하여 반환한다.

var a = new Array(1,2,3);     // a[0] = 1, a[1] = 2, a[2] = 3
a.reverse();                       // now a[0] = 3, a[1] = 2. a[2] = 1
var s = a.join();                  // s == "3,2,1"

sort()
Array.sort() 메서드는 배열 안의 원소들을 정렬하여 반환한다.

var a = new Array("c", "a", "b");
a.sort();
var s = a.join(", ");     // s== "a, b, c"

알파벳순이 아니라 다른 순서로 배열을 정렬하려면 sort() 메서드의 전달인자를 통해 비교 함수를 직접 명시해주어야 한다. 비교 함수는 전달인자를 두개 받아서, 정렬된 배열 상에서 어떤 것이 먼저 나타나야 하는지 판단하는데 사용 된다. 만약 첫 번째 전달인자가 두 번째보다 먼저 나타나야 한다면 비교 함수는 0보다 작은 숫자를 반환해야 한다. 첫 번째 전달인자가 두 번째보다 뒤에 나타나야 한다면 0보다 큰 숫자를 반환하며 두 값이 동등하다면 0을 반환해야 한다.
var a = [33, 4, 1111, 222];
a.sort();                   // 알파벳순 : 1111, 222, 33, 4
a.sort(function(a,b) { // 번호순 : 4, 33, 222, 1111
     return a-b;
     });

concat()
Array.concat() 메서드는 본래 배열의 모든 원소에 concat() 메서드의 전달인자들을 전부 이어붙인 배열을 새롭게 생성하여 반환한다.
var a = [1, 2, 3];
a.concat(4, 5);            // [1,2,3,4,5]
a.concat([4,5]);          // [1,2,3,4,5]
a.concat([4.5], [6,7]); // [1,2,3,4,5,6,7]
a.concat([4, [5,[6,7]]]);  // [1,2,3,4,5,[6,7]]

slice()
Array.slice() 메서드는 배열의 일부분 혹은 부분 배열을 반환한다.
var a = [1,2,3,4,5];
a.slice(0, 3);           // [1,2,3]
a.slice(3);              // [4,5]
a.slice(1, -1);         // [2,3,4]
a.slice(-3,-2);        // [3]

splice()
Array.splice() 메서드는 배열에 원소를 삽입하거나 원소를 제거하려 할 때 범용적으로 사용할 수 있는 메서드이다.
var a = [1,2,3,4,5,6,7,8];
var a.splice(4);          // [5,6,7,8] , a는 [1,2,3,4];
var a.splice(1,2);       // [2,3] , a는 [1,4];
var a.splice(1,1);       // [4] , a는 [1]

push() & pop()
위 메서드를 사용하면 배열을 마치 스택인 것처럼 조작할 수 있다.
push() 메서드는 하나 혹은 그 이상의 원소들을 배열의 끝 부분에 이어 붙이고 배열의 새로운 길이를 반환한다.
pop() 메서드는 push()와 반대로 작동한다. 즉 pop() 메서드는 배열의 마지막 원소를 제거하고 배열의 길이를 감소시킨 후 배열에서 제거한 원소를 반환한다.
var stack = [];           // stack:[]
stack.push(1,2);        // stack:[1,2]        2를 반환
stack.pop();              // stack:[1]          2를 반환
stack.push(3);           // stack:[1,3]       3를 반환
stack.pop();              // stack:[1]          3를 반환
stack.push(4,5);        // stack:[1, [4,5]] 2를 반환
stack.pop();              // stack:[1]          [4,5]를 반환
stack.pop();              // stack:[]           1를 반환 조
unshift() & shift()
push(), pop()과 유사하며 이 메서들은 배열의 끝이 아니라 배열의 맨 앞에 원소를 삽입하고 제거한다.
var a = [];              // a:[]
a.unshift(1);           // a:[1]
a.unshift(22);          // a:[22, 1]
a.shift();                 // a:[1]
a.unshift(3,[4,5]);    // a:[3,[4,5],1]
a.shift();                 // a:[[4,5],1]
a.shift();                 // a:[1]
a.shift();                 // a:[]



4.조건문 & 반복문


	1. 조건문 : 조건에 따라 특정 실행문을 실행시킬 수 있다.
: if, else, else if



	1. 반복문 : 실행문을 지정한 횟수 만큼 반복해서 실행시킬 수 있다.
: while, for


조건문 :
조건문은 조건식이 값이 참인지 아니면 거짓인지에 따라 실행문의 제어가 결정된다.

기본형 :
if(조건식) {
실행문;
}

var num = 10;
if(num<500) { //조건을 만족하여 true를 반환
     document.write("hello");

 반복문 :
while : 조건식을 만족할 때까지 실행문을 여러 번 반복하여 실행시킬 수 있다.

기본형 :
var 변수 = 초기값;
while(1,3 조건식) {
     2
     실행문;
     증감식;
}

for : 조건식을 만족할 때까지 특정 실행문을 반복하여 실행.
기본형
for(초기값; 조건식; 증감식) {
     실행문;
}
